#!/usr/bin/env python3

import argparse
import csv
import gzip
import json
import os
import random
import re
import sqlite3
import sys

def table_reader(file, delim, kidx, vidx, testing):
	data = {}
	counter = 0
	with gzip.open(file, 'rt') as fp:
		header = next(fp)
		reader = csv.reader(fp, delimiter=delim)
		for row in reader:
			counter += 1
			if testing and counter > 5000: break
			key = row[kidx]
			val = row[vidx]
			if val == '': continue
			if key not in data: data[key] = set()
			data[key].add(val)
	return data

def create_database(arg):
	if os.path.exists(arg.database): sys.exit('database already exists')
	con = sqlite3.connect(arg.database)
	cur = con.cursor()

	# go_basic
	cur.execute('CREATE TABLE go(go_id, label, desc)')
	with gzip.open(f'{arg.build}/go_basic.json.gz', 'rt') as fp:
		data = json.load(fp)
	for record in data['graphs'][0]['nodes']:
		go_id = record['id'].split('/')[4]
		if not go_id.startswith('GO'): continue # skipping BFOs
		if 'deprecated' in record['meta']: continue
		go_id = record['id'].split('/')[4]
		label = record['lbl']
		desc = record['meta']['definition']['val']
		cur.execute(f'INSERT INTO go VALUES ("{go_id}", "{label}", "{desc}")')
	con.commit()

	# mgi_gpi
	cur.execute('CREATE TABLE genes(mgi_id, symbol, desc)')
	with gzip.open(f'{arg.build}/mgi_gpi.gz', 'rt') as fp:
		for line in fp:
			if line.startswith('!'): continue
			f = line.split('\t')
			mgi, symbol, desc = f[0], f[1], f[2]
			m = re.match(r'MGI:(MGI:\d+)', mgi)
			if not m: continue
			mgi_id = m.group(1)
			cur.execute(f'INSERT INTO genes VALUES ("{mgi_id}", "{symbol}", "{desc}")')
	con.commit()

	# mgi_gaf
	cur.execute('CREATE TABLE mgi2go(mgi_id, go_id)')
	with gzip.open(f'{arg.build}/mgi_gaf.gz', 'rt') as fp:
		for line in fp:
			if line.startswith('!'): continue
			f = line.split('\t')
			mgi_id, go_id = f[1], f[4]
			if not re.match(r'MGI:\d+', mgi_id): continue
			go_id = go_id.replace(':', '_')
			cur.execute(f'INSERT INTO mgi2go VALUES ("{mgi_id}", "{go_id}")')
	con.commit()



	return

	#mgi2mmrrc = table_reader(arg.mmrrc, ',', 10, 0, arg.testing)
	#go2mgi = table_reader(arg.mgi, '\t', 4, 1, arg.testing)





	#cur.execute('CREATE TABLE go2mm(goid, mmid)')
	#cur.execute('CREATE INDEX idx ON go2mm(goid, mmid)')
	con.commit()

	go2mmrrc = {}
	for go_id, mgi_ids in go2mgi.items():
		if not go_id.startswith('GO'): continue
		for mgi_id in mgi_ids:
			if not re.match(r'^MGI:\d+$', mgi_id): continue
			if mgi_id not in mgi2mmrrc: continue
			for mmrrc_id in mgi2mmrrc[mgi_id]:
				if go_id not in go2mmrrc: go2mmrrc[go_id] = []
				go2mmrrc[go_id].append(mmrrc_id)

	for goid, mmids in go2mmrrc.items():
		for mmid in mmids:
			cur.execute(f'INSERT INTO go2mm VALUES("{goid}","{mmid}")')
		con.commit()

def query_database(arg):
	con = sqlite3.connect(arg.database)
	cur = con.cursor()
	result = {}
	for id in arg.goids:
		r = cur.execute(f'SELECT mmid from go2mm WHERE goid="{id}"').fetchall()
		con.commit()
		mids = [x[0] for x in r]
		result[id] = mids
	print(json.dumps(result, indent=2))

def download_files(arg):
	os.system(f'mkdir -p {arg.build}')
	if not os.path.exists(f'{arg.build}/mgi_gpi.gz'):
		os.system(f'curl {arg.mgi_gpi} > {arg.build}/mgi_gpi.gz')
	if not os.path.exists(f'{arg.build}/mgi_gaf.gz'):
		os.system(f'curl {arg.mgi_gaf} > {arg.build}/mgi_gaf.gz')
	if not os.path.exists(f'{arg.build}/go_basic.json.gz'):
		os.system(f'curl {arg.go_basic} | gzip > {arg.build}/go_basic.json.gz')

#########
## CLI ##
#########

parser = argparse.ArgumentParser(description='GO to MMRRC database utility')
sub = parser.add_subparsers(required=True, help='sub-commands')

## create sub-command ##
sub1 = sub.add_parser('create', help='make database')
sub1.add_argument('--build', required=False, metavar='<dir>',
	default='build', help='directory of temp files [%(default)s]')
sub1.add_argument('--database', required=False, metavar='<file.db>',
	default='mmsearch.db', help='database [%(default)s]')
sub1.add_argument('--testing', action='store_true')
sub1.set_defaults(func=create_database)

## query sub-command ##
sub2 = sub.add_parser('query', help='query database')
sub2.add_argument('goids', nargs='+', metavar='<GO:ID>',
	help='GO identifiers')
sub2.add_argument('--database', required=False, metavar='<file.db>',
	default='g2m.db', help='database [%(default)s]')
sub2.set_defaults(func=query_database)

## download sub-command ##
sub3 = sub.add_parser('download', help='download MMRRC and MGI files')
sub3.add_argument('--mmrrc', required=False, metavar='<url>',
	default='https://www.mmrrc.org/...',
	help='[%(default)s]')
sub3.add_argument('--mgi_gpi', required=False, metavar='<url>',
	default='https://current.geneontology.org/annotations/mgi.gpi.gz',
	help='URL to MGI GPI file [%(default)s]')
sub3.add_argument('--mgi_gaf', required=False, metavar='<url>',
	default='https://current.geneontology.org/annotations/mgi.gaf.gz',
	help='URL TO MGI GAF file [%(default)s]')
sub3.add_argument('--go_basic', required=False, metavar='<url>',
	default='https://current.geneontology.org/ontology/go-basic.json',
	help='URL to GO basic json [%(default)s]')
sub3.add_argument('--build', required=False, metavar='<dir>',
	default='build', help='directory for temp files [%(default)s]')
sub3.set_defaults(func=download_files)

## finish up ##
arg = parser.parse_args()
arg.func(arg)
