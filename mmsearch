#!/usr/bin/env python3

import argparse
import csv
import gzip
import json
import os
import random
import re
import sqlite3
import sys
import time


def create_database(arg):
	if os.path.exists(arg.database): sys.exit('database already exists')
	con = sqlite3.connect(arg.database)
	cur = con.cursor()

	# go_nodes table from go_basic.json.gz
	cur.execute('CREATE TABLE go_nodes(go_id PRIMARY KEY, label, desc)')
	with gzip.open(f'{arg.build}/go_basic.json.gz', 'rt') as fp:
		data = json.load(fp)
	for record in data['graphs'][0]['nodes']:
		m = re.search(r'(GO_\d+)', record['id'])
		if not m: continue
		if 'deprecated' in record['meta']: continue
		go_id = m.group(1)
		go_id = record['id'].split('/')[4]
		label = record['lbl']
		desc = record['meta']['definition']['val']
		cur.execute(f'INSERT INTO go_nodes VALUES ("{go_id}", "{label}", "{desc}")')
	con.commit()

	# mp table from mp.json.gz (variant of above not worth abstracting)
	cur.execute('CREATE TABLE mp(mp_id PRIMARY KEY, label, desc)')
	with gzip.open(f'{arg.build}/mp.json.gz', 'rt') as fp:
		data = json.load(fp)
	for record in data['graphs'][0]['nodes']:
		if 'meta' not in record: continue
		m = re.search(r'(MP_\d+)', record['id'])
		if not m: continue
		if 'deprecated' in record['meta']: continue
		mp_id = m.group(1)
		label = record['lbl']
		desc = record['meta']['definition']['val'] if 'definition' in record['meta'] else ''
		cur.execute(f'INSERT INTO mp VALUES ("{mp_id}", "{label}", "{desc}")')
	con.commit()

	# genes table from mgi_gpi.gz
	cur.execute('CREATE TABLE genes(symbol PRIMARY KEY, mgi_id UNIQUE, desc)')
	with gzip.open(f'{arg.build}/mgi_gpi.gz', 'rt') as fp:
		for line in fp:
			if line.startswith('!'): continue
			f = line.split('\t')
			mgi, symbol, desc = f[0], f[1], f[2]
			m = re.match(r'MGI:(MGI:\d+)', mgi)
			if not m: continue
			mgi_id = m.group(1)
			cur.execute(f'INSERT OR IGNORE INTO genes VALUES ("{symbol}", "{mgi_id}", "{desc}")')
	con.commit()

	# mgi2go table from mgi_gaf.gz
	cur.execute('CREATE TABLE mgi2go(mgi_id, go_id)')
	cur.execute('CREATE INDEX idx1 ON mgi2go(mgi_id)')
	cur.execute('CREATE INDEX idx2 ON mgi2go(go_id)')
	with gzip.open(f'{arg.build}/mgi_gaf.gz', 'rt') as fp:
		for line in fp:
			if line.startswith('!'): continue
			f = line.split('\t')
			mgi_id, go_id = f[1], f[4]
			if not re.match(r'MGI:\d+', mgi_id): continue
			go_id = go_id.replace(':', '_')
			cur.execute(f'INSERT INTO mgi2go VALUES ("{mgi_id}", "{go_id}")')
	con.commit()

	# mmrrc2mgi, mmrrc2mp tables from mmrrc.gz
	data = {}
	with gzip.open(f'{arg.build}/mmrrc.gz', 'rt') as fp:
		header = next(fp)
		for row in csv.reader(fp, delimiter=','):
			mmrrc_id = row[0]
			mgi_id = row[10]
			mp_txt = row[15]
			if mmrrc_id not in data:
				data[mmrrc_id] = {'mgi': set(), 'mp': set()}
			if mgi_id != '': data[mmrrc_id]['mgi'].add(mgi_id)
			if mp_txt != '': data[mmrrc_id]['mp'].add(mp_txt)

	cur.execute('CREATE TABLE mmrrc2mgi(mmrrc_id, mgi_id)')
	cur.execute('CREATE INDEX idx3 ON mmrrc2mgi(mmrrc_id)')
	cur.execute('CREATE INDEX idx4 ON mmrrc2mgi(mgi_id)')
	for mmrrc_id in data:
		for mgi_id in data[mmrrc_id]['mgi']:
			cur.execute(f'INSERT INTO mmrrc2mgi VALUES ("{mmrrc_id}", "{mgi_id}")')
	con.commit()

	cur.execute('CREATE TABLE mmrrc2mp(mmrrc_id, mp_id)')
	cur.execute('CREATE INDEX idx5 ON mmrrc2mp(mmrrc_id)')
	cur.execute('CREATE INDEX idx6 ON mmrrc2mp(mp_id)')
	for mmrrc_id in data:
		if len(data[mmrrc_id]['mp']) == 0: continue
		mp_txt = data[mmrrc_id]['mp'].pop() # there is only 1
		for m in re.finditer(r'MP:\d+', mp_txt):
			mp_id = m.group()
			mp_id = mp_id.replace(':', '_')
			cur.execute(f'INSERT INTO mmrrc2mp VALUES ("{mmrrc_id}", "{mp_id}")')
	con.commit()

def query_database(arg):
	con = sqlite3.connect(f'file:{arg.database}?mode=ro', uri=True)
	cur = con.cursor()
	result = {}
	for id in arg.goids:
		r = cur.execute(f'SELECT mmid from go2mm WHERE goid="{id}"').fetchall()
		con.commit()
		mids = [x[0] for x in r]
		result[id] = mids
	print(json.dumps(result, indent=2))

def download_files(arg):
	os.system(f'mkdir -p {arg.build}')
	if not os.path.exists(f'{arg.build}/mgi_gpi.gz'):
		os.system(f'curl {arg.mgi_gpi} > {arg.build}/mgi_gpi.gz')
	if not os.path.exists(f'{arg.build}/mgi_gaf.gz'):
		os.system(f'curl {arg.mgi_gaf} > {arg.build}/mgi_gaf.gz')
	if not os.path.exists(f'{arg.build}/go_basic.json.gz'):
		os.system(f'curl {arg.go_basic} | gzip > {arg.build}/go_basic.json.gz')
	if not os.path.exists(f'{arg.build}/mp.json.gz'):
		os.system(f'curl {arg.mp} | gzip > {arg.build}/mp.json.gz')

def testing(arg):
	con = sqlite3.connect(f'file:{arg.database}?mode=ro', uri=True)
	cur = con.cursor()
	r = cur.execute(f'SELECT symbol, mgi_id from genes limit 1000').fetchall()
	symbols = []
	mgi_ids = []
	for symbol, mgi_id in r:
		symbols.append(symbol)
		mgi_ids.append(mgi_id)
	r = cur.execute(f'SELECT go_id FROM go_nodes limit 1000').fetchall()
	go_ids = [x[0] for x in r]
	r = cur.execute(f'SELECT mmrrc_id FROM mmrrc2mgi limit 1000').fetchall()
	mmrrc_ids = [x[0] for x in r]

	t0 = time.time()
	for symbol in symbols:
		r = cur.execute(f'SELECT mgi_id FROM genes WHERE symbol="{symbol}"').fetchall()
	t1 = time.time()
	for mgi_id in mgi_ids:
		r = cur.execute(f'SELECT symbol FROM genes WHERE mgi_id="{mgi_id}"').fetchall()
	t2 = time.time()
	for mgi_id in mgi_ids:
		r = cur.execute(f'SELECT go_id FROM mgi2go WHERE mgi_id="{mgi_id}"').fetchall()
	t3 = time.time()
	for go_id in go_ids:
		r = cur.execute(f'SELECT mgi_id FROM mgi2go WHERE go_id="{go_id}"').fetchall()
	t4 = time.time()
	for mid in mmrrc_ids:
		r = cur.execute(f'SELECT mgi_id FROM mmrrc2mgi WHERE mmrrc_id="{mid}"').fetchall()
	t5 = time.time()
	for mgi_id in mgi_ids:
		r = cur.execute(f'SELECT mmrrc_id FROM mmrrc2mgi WHERE mgi_id="{mgi_id}"').fetchall()
	t6 = time.time()
	for mid in mmrrc_ids:
		r= cur.execute(f'SELECT mp_id FROM mmrrc2mp WHERE mmrrc_id="{mid}"').fetchall()
	t7 = time.time()

	# need to do a join at some point
	#for go_id in go_ids:
	#	r = cur.execute(f'SELECT

	print(t1 - t0)
	print(t2 - t1)
	print(t3 - t2)
	print(t4 - t3)
	print(t5 - t4)
	print(t6 - t5)
	print(t7 - t6)


#########
## CLI ##
#########

parser = argparse.ArgumentParser(description='GO to MMRRC database utility')
sub = parser.add_subparsers(required=True, help='sub-commands')

## create sub-command ##
sub1 = sub.add_parser('create', help='make database')
sub1.add_argument('--build', required=False, metavar='<dir>',
	default='build', help='directory of temp files [%(default)s]')
sub1.add_argument('--database', required=False, metavar='<file.db>',
	default='mmsearch.db', help='database [%(default)s]')
sub1.add_argument('--testing', action='store_true')
sub1.set_defaults(func=create_database)

## query sub-command ##
sub2 = sub.add_parser('query', help='query database')
sub2.add_argument('goids', nargs='+', metavar='<GO:ID>',
	help='GO identifiers')
sub2.add_argument('--database', required=False, metavar='<file.db>',
	default='mmsearch.db', help='database [%(default)s]')
sub2.set_defaults(func=query_database)

## download sub-command ##
sub3 = sub.add_parser('download', help='download MMRRC and MGI files')
sub3.add_argument('--mmrrc', required=False, metavar='<url>',
	default='https://www.mmrrc.org/...',
	help='[%(default)s]')
sub3.add_argument('--mgi_gpi', required=False, metavar='<url>',
	default='https://current.geneontology.org/annotations/mgi.gpi.gz',
	help='URL to MGI GPI file [%(default)s]')
sub3.add_argument('--mgi_gaf', required=False, metavar='<url>',
	default='https://current.geneontology.org/annotations/mgi.gaf.gz',
	help='URL TO MGI GAF file [%(default)s]')
sub3.add_argument('--go_basic', required=False, metavar='<url>',
	default='https://current.geneontology.org/ontology/go-basic.json',
	help='URL to GO basic json [%(default)s]')
sub3.add_argument('--mp', required=False, metavar='<url>',
	default='https://www.informatics.jax.org/downloads/reports/mp.json',
	help='URL to mammalian phenotype json')
sub3.add_argument('--build', required=False, metavar='<dir>',
	default='build', help='directory for temp files [%(default)s]')
sub3.set_defaults(func=download_files)

## test sub-command ##
sub4 = sub.add_parser('test', help='internal testing')
sub4.add_argument('--database', required=False, metavar='<file.db>',
	default='mmsearch.db', help='database [%(default)s]')
sub4.set_defaults(func=testing)

## finish up ##
arg = parser.parse_args()
arg.func(arg)
